# [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/description/)

## 题目描述
给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```

匹配应该覆盖整个字符串 (s) ，而不是部分字符串。

说明:
- s 可能为空，且只包含从 a-z 的小写字母。
- p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例1：
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例2：
```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

示例 3:
```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```
示例 4:
```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```
示例 5:
```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

## 个人思路
- 动态规划 : 从最简单的子问题出发，利用已知的子问题的答案，得到更复杂的子问题的答案，循环往复，最终得到祖先问题的答案。

- 假设有字符串[s],内容为[s0s1s2...sx],模式[p],内容为[p0p1p2....py]
```
回想阶乘的例子,n! = (n-1)!*n,一直递归到最小的子问题,即1!=1,最后得到n的阶乘
```

- 在此处问题中,也可以沿用,递归求子串是否匹配,直到最小的子串,模式p的长度小于等于2时,即 [s0s1,p0p1],就可以算出是否模式匹配

```
- 如果py不是*,那么sx==py或者py=='.',字符串s才能匹配模式p,符合要求
- 如果py是*,那么py-1py有两种情况,符合匹配要求
1. 匹配0个字符:  [s0s1s2....sx]依然能匹配[p0p1p2...py-3]
2. 匹配1个以上字符: sx==py或者py=='.',此时,去掉sx,字符串s与模式p可以匹配,即[s0s1s2....sx-1]依然能匹配[p0p1p2....py]
```

## 总结
- 以上思路不是本人独立思考出的,而是从一篇[博客](https://segmentfault.com/a/1190000012016037)中找到了思路,然后在基础上做了思考和消化,进行阐述的,在此感谢作者的分享
- 此处本人的算法代码是根据自己的理解,采用比较容易懂的递归的方式去写的,已通过[leetcode-cn官网](https://leetcode-cn.com/problems/regular-expression-matching/description/)的测试用例,相比其它,本人代码量较大,但是容易看懂
- main.go文件中也包含了另外一种非递归版本的算法,代码量小很多,读者可以对比研究
